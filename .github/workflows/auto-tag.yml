name: Auto Tag

on:
  push:
    branches:
      - main
    paths:
      - '**/*.go'
      - 'go.mod'
      - 'go.sum'
      - 'cmd/**'
      - 'pkg/**'
      - 'internal/**'

# Set top-level permissions to read-all for security
# Required write permissions are explicitly set at job level
permissions: read-all

jobs:
  auto-tag:
    name: Auto Tag Release
    runs-on: ubuntu-latest
    permissions:
      # NOTE: contents:write is required for automated tagging functionality
      # This is necessary to create git tags and update version files
      contents: write     # Required to create git tags and update .release-version file
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@002fdce3c6a235733a90a27c80493a3241e56863 # v2.12.1
        with:
          disable-sudo: true
          egress-policy: audit

      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get current version
        id: current_version
        run: |
          # Get the latest tag, default to v0.0.0 if none exists
          if git describe --tags --abbrev=0 >/dev/null 2>&1; then
            LATEST_TAG=$(git describe --tags --abbrev=0)
            echo "LATEST_TAG=$LATEST_TAG" >> $GITHUB_ENV
            echo "Found existing tag: $LATEST_TAG"
          else
            LATEST_TAG="v0.0.0"
            echo "LATEST_TAG=$LATEST_TAG" >> $GITHUB_ENV
            echo "No existing tags found, will start from: $LATEST_TAG"
          fi

      - name: Determine version bump
        id: version_bump
        run: |
          # Check commit messages for version bump indicators
          if [ "${{ env.LATEST_TAG }}" = "v0.0.0" ]; then
            # No tags exist, use all commits
            COMMITS=$(git log --oneline)
            echo "No previous tags found, analyzing all commits:"
          else
            # Tags exist, check commits since last tag
            COMMITS=$(git log ${{ env.LATEST_TAG }}..HEAD --oneline)
            echo "Commits since last tag ${{ env.LATEST_TAG }}:"
          fi
          echo "$COMMITS"
          
          # Check if we should skip tagging
          if echo "$COMMITS" | grep -i "\[skip-tag\]" > /dev/null; then
            echo "SKIP_TAG=true" >> $GITHUB_ENV
            echo "Skipping tag creation due to [skip-tag] in commit message"
            exit 0
          fi
          
          # Default to patch bump
          BUMP_TYPE="patch"
          
          # Check for breaking changes or major features
          if echo "$COMMITS" | grep -i -E "(BREAKING|major|breaking change)" > /dev/null; then
            BUMP_TYPE="major"
          elif echo "$COMMITS" | grep -i -E "(feat|feature|minor)" > /dev/null; then
            BUMP_TYPE="minor"
          fi
          
          echo "SKIP_TAG=false" >> $GITHUB_ENV
          echo "BUMP_TYPE=$BUMP_TYPE" >> $GITHUB_ENV
          echo "Version bump type: $BUMP_TYPE"

      - name: Calculate new version
        id: new_version
        run: |
          # Parse current version
          CURRENT_VERSION="${{ env.LATEST_TAG }}"
          # Remove 'v' prefix if present
          CURRENT_VERSION=${CURRENT_VERSION#v}
          
          # Split version into parts
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          
          # Default values if parsing fails
          MAJOR=${MAJOR:-0}
          MINOR=${MINOR:-0}
          PATCH=${PATCH:-0}
          
          # If starting from v0.0.0 (no previous tags), start with v0.1.0
          if [ "${{ env.LATEST_TAG }}" = "v0.0.0" ]; then
            NEW_VERSION="v0.1.0"
            echo "Starting from first version: $NEW_VERSION"
          else
            # Bump version based on type
            case "${{ env.BUMP_TYPE }}" in
              "major")
                MAJOR=$((MAJOR + 1))
                MINOR=0
                PATCH=0
                ;;
              "minor")
                MINOR=$((MINOR + 1))
                PATCH=0
                ;;
              "patch")
                PATCH=$((PATCH + 1))
                ;;
            esac
            NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
            echo "Bumped version: $NEW_VERSION (type: ${{ env.BUMP_TYPE }})"
          fi
          
          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV

      - name: Check if tag already exists
        id: check_tag
        run: |
          # Skip check if we're supposed to skip tagging
          if [ "${{ env.SKIP_TAG }}" = "true" ]; then
            echo "TAG_EXISTS=true" >> $GITHUB_ENV
            echo "Skipping tag creation"
            exit 0
          fi
          
          if git rev-parse "${{ env.NEW_VERSION }}" >/dev/null 2>&1; then
            echo "TAG_EXISTS=true" >> $GITHUB_ENV
            echo "Tag ${{ env.NEW_VERSION }} already exists"
          else
            echo "TAG_EXISTS=false" >> $GITHUB_ENV
            echo "Tag ${{ env.NEW_VERSION }} does not exist, will create"
          fi

      - name: Update .release-version file
        if: env.TAG_EXISTS == 'false' && env.SKIP_TAG == 'false'
        run: |
          # Configure git
          git config --local user.name "github-actions[bot]"
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          
          # Update .release-version file with new version (without 'v' prefix)
          echo "${NEW_VERSION#v}" > .release-version
          
          # Commit and push the updated version file
          git add .release-version
          git commit -m "chore: update version to ${NEW_VERSION#v} [skip-tag]"
          git push origin main
          
          echo "Updated .release-version to: ${NEW_VERSION#v}"

      - name: Create and push tag
        if: env.TAG_EXISTS == 'false' && env.SKIP_TAG == 'false'
        run: |
          # Create annotated tag with commit info
          COMMIT_MSG=$(git log -1 --pretty=format:"%s")
          git tag -a "${{ env.NEW_VERSION }}" -m "Release ${{ env.NEW_VERSION }}: $COMMIT_MSG"
          
          # Push tag
          git push origin "${{ env.NEW_VERSION }}"
          
          echo "Created and pushed tag: ${{ env.NEW_VERSION }}"

      - name: Tag created successfully
        if: env.TAG_EXISTS == 'false' && env.SKIP_TAG == 'false'
        run: |
          echo "Tag ${{ env.NEW_VERSION }} created successfully"
          echo "Release workflow will be triggered automatically"
          echo "Binaries will be available in ~5-10 minutes" 